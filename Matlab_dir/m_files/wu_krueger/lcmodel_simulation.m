function sim = lcmodel_simulation(  par, ind, nugrid, nFgrid, Agrid, ugrid, u_prob, Fgrid, F_transit_mat, F_initial_prob, ...
                                    policy_C, policy_H1, policy_H2, policy_A_prime, policy_V, varargin)
%{  
    'Consumption Inequality across Heterogeneous Families'
    This function simulates a panel of households based on the policy  
    functions generated by the quantitative model..
   
    This code is an adaptation to the original code provided by 
    Wu & Krueger (2020), 'Consumption Insurance Against Wage Risk',
    published in AEJ-Macro.

    Alexandros Theloudis
    -----------------------------------------------------------------------                                
%}   
                                    
    %   Initial statements:
    rng(10086) % random seed

    %   Initialize arrays to hold simulations:
    sim.A   = NaN(par.sim_N, par.T+1);  % assets
    sim.iF  = NaN(par.sim_N, par.R);    % permanent wage shocks index
    sim.C   = NaN(par.sim_N, par.T);    % consumption
    sim.H1  = NaN(par.sim_N, par.R);    % male hours
    sim.H2  = NaN(par.sim_N, par.R);    % female hours
    sim.F1  = NaN(par.sim_N, par.R);    % male permanent wage component
    sim.F2  = NaN(par.sim_N, par.R);    % female permanent wage component
    sim.u1  = NaN(par.sim_N, par.R);    % male transitory wage component
    sim.u2  = NaN(par.sim_N, par.R);    % female transitory wage componen
    sim.W1  = NaN(par.sim_N, par.R);    % male wage
    sim.W2  = NaN(par.sim_N, par.R);    % female wage

    %   Initial net worth is zero for all households:
    sim.A(:,1) = 0 ;
    
    %   Obtain value of consumption if it is passed on to the model:
    nVarargs = length(varargin);
    if nVarargs>0
        policy_VC  = varargin{1};
        policy_VH  = varargin{2};
        policy_VH1 = varargin{3};
        policy_VH2 = varargin{4};
    end
    
    
    %%  A. INITIAL PERMANENT AND ALL TRANSITORY WAGE COMPONENTS.
    %   Simulate initial permanent and all transitory wage components. 
    %   -------------------------------------------------------------------
    
    %   Index of initial permanent component:
    sim.iF(:,1) = discretize(random('Uniform', 0, 1, [par.sim_N,1]), [0, cumsum(F_initial_prob)]);
    
    %   Index of transitory shocks:
    sim.iu      = discretize(random('Uniform', 0, 1, [par.sim_N,par.R]), [0, cumsum(u_prob)]);
    sim.iu(:,1) = (nugrid+1)/2;

    
    %%  B. SIMULATE STARTING FROM BEGINNING OF LIFE.
    %   Simulate consumption and hours. 
    %   -------------------------------------------------------------------

    %   Loop over working life:
    for it=1:par.R   
        
        %   Declare multidimensional grid coordinates over assets and wage shocks:
        [temp_A_coor,temp_iF_coor,temp_iu_coor] = ndgrid(Agrid(:,it), (1:nFgrid)', (1:nugrid)');
        
        %   Declare interpolation objects for consumption, hours, and future  
        %   assets over multidimensional grid:
        temp_fun_C          = griddedInterpolant(temp_A_coor, temp_iF_coor, temp_iu_coor, policy_C(:,:,:,it));
        temp_fun_H1         = griddedInterpolant(temp_A_coor, temp_iF_coor, temp_iu_coor, policy_H1(:,:,:,it));
        temp_fun_H2         = griddedInterpolant(temp_A_coor, temp_iF_coor, temp_iu_coor, policy_H2(:,:,:,it));
        temp_fun_A_prime    = griddedInterpolant(temp_A_coor, temp_iF_coor, temp_iu_coor, policy_A_prime(:,:,:,it));

        %   Simulate consumption, hours, and future assets:
        sim.C(:,it)         = temp_fun_C(sim.A(:,it), sim.iF(:,it), sim.iu(:,it));
        sim.H1(:,it)        = temp_fun_H1(sim.A(:,it), sim.iF(:,it), sim.iu(:,it));
        sim.H2(:,it)        = temp_fun_H2(sim.A(:,it), sim.iF(:,it), sim.iu(:,it));
        sim.A(:,it+1)       = temp_fun_A_prime(sim.A(:,it), sim.iF(:,it), sim.iu(:,it));
        
        %   Correct future assets if they lie below borrowing constraint:
        sim.A(sim.A(:,it+1)<par.bc(it+1),it+1) = par.bc(it+1);
        
        %   Retrieve permanent and transitory wages from random index:
        sim.F1(:,it)        = Fgrid(1,sim.iF(:,it),it);
        sim.F2(:,it)        = Fgrid(2,sim.iF(:,it),it);
        sim.u1(:,it)        = ugrid(1,sim.iu(:,it));
        sim.u2(:,it)        = ugrid(2,sim.iu(:,it));
        
        %   Obtain male & female wages:
        sim.W1(:,it) = par.w1*exp(par.gtrend1(it)+sim.F1(:,it)+sim.u1(:,it));
        sim.W2(:,it) = par.w2*exp(par.gtrend2(it)+sim.F2(:,it)+sim.u2(:,it));
        
        %   Obtain simulated value function in first period of life
        %   (reflects continuation value over entire life):
        if it==1
            temp_fun_V          = griddedInterpolant(temp_A_coor, temp_iF_coor, temp_iu_coor, policy_V(:,:,:,it));
            sim.V               = temp_fun_V(sim.A(:,it), sim.iF(:,it), sim.iu(:,it));
            %   -value of consumption when model is separable:
            if ind.separable==1
                temp_fun_VC     = griddedInterpolant(temp_A_coor, temp_iF_coor, temp_iu_coor, policy_VC(:,:,:,it));
                sim.VC          = temp_fun_VC(sim.A(:,it), sim.iF(:,it), sim.iu(:,it)); 
                temp_fun_VH     = griddedInterpolant(temp_A_coor, temp_iF_coor, temp_iu_coor, policy_VH(:,:,:,it));
                sim.VH          = temp_fun_VH(sim.A(:,it), sim.iF(:,it), sim.iu(:,it));
                temp_fun_VH1    = griddedInterpolant(temp_A_coor, temp_iF_coor, temp_iu_coor, policy_VH1(:,:,:,it));
                sim.VH1         = temp_fun_VH1(sim.A(:,it), sim.iF(:,it), sim.iu(:,it));
                temp_fun_VH2    = griddedInterpolant(temp_A_coor, temp_iF_coor, temp_iu_coor, policy_VH2(:,:,:,it));
                sim.VH2         = temp_fun_VH2(sim.A(:,it), sim.iF(:,it), sim.iu(:,it));
            end %ind.separable
        end %it
        
        %   Obtain index of permanent wage component for next period:
        if it<par.R
            for iF=1:nFgrid
                temp_ind_iF = (sim.iF(:,it)==iF);
                sim.iF(temp_ind_iF,it+1) = discretize(random('Uniform', 0, 1, [sum(temp_ind_iF),1]), [0, cumsum(F_transit_mat(iF,:,it))]);
            end
        end
    end
    
    %   Loop over retirement - deterministically using 1) the sequential budget 
    %   constraint from R+1 forward until T; and 2) the consumption Euler 
    %   equation u'(C_R) = \beta*(1+r)*u'(C_R+1):
    for it=par.R+1:par.T
        sim.C(:,it)   = (sum((1/(1+par.r)).^(0:1:par.T-it))*par.rb+(1+par.r)*sim.A(:,it))/sum((((1+par.r)/(1+par.delta))^(1/par.sigma)/(1+par.r)).^(0:1:par.T-it));
        sim.A(:,it+1) = par.rb+(1+par.r)*sim.A(:,it)-sim.C(:,it);
    end
    
    %   Replace possible negative values for hours and consumption:
    sim.C(sim.C<=0)     = 1e-6;
    sim.H1(sim.H1<=0)   = 1e-6;
    sim.H2(sim.H2<0)    = 0;

    %   Assemble simulated male, female, and household pre-tax earnings:
    sim.Y1  = sim.W1.*sim.H1;
    sim.Y2  = sim.W2.*sim.H2;
    sim.Y   = sim.Y1+sim.Y2;
    
    %   Assemble permanent wage shocks:
    sim.v1  = diff(sim.F1,1,2);
    sim.v2  = diff(sim.F2,1,2);
end